import { BrowserWindow, nativeImage } from 'electron';
import { promises as fs } from 'fs';
import * as path from 'path';

export class FormatConverter {
  /**
   * 将 HTML 内容转换为图片
   */
  static async htmlToImage(
    htmlContent: string, 
    format: 'png' | 'jpg', 
    options: { width?: number; height?: number; quality?: number } = {}
  ): Promise<Buffer> {
    const { width = 800, height = 600, quality = 90 } = options;
    
    // 创建一个隐藏的 BrowserWindow 来渲染 HTML
    const hiddenWindow = new BrowserWindow({
      width,
      height,
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        webSecurity: false
      }
    });

    try {
      // 创建完整的 HTML 页面
      const fullHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            body {
              margin: 0;
              padding: 20px;
              background: white;
              font-family: 'Computer Modern', 'Latin Modern Roman', serif;
              display: flex;
              justify-content: center;
              align-items: center;
              min-height: calc(100vh - 40px);
              box-sizing: border-box;
            }
            .content {
              text-align: center;
              font-size: 2em;
              line-height: 1.2;
            }
            /* KaTeX 样式兼容 */
            .katex { font-size: inherit !important; }
            .katex-display { margin: 0 !important; }
          </style>
        </head>
        <body>
          <div class="content">
            ${htmlContent}
          </div>
        </body>
        </html>
      `;

      // 加载 HTML 内容
      await hiddenWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(fullHtml)}`);
      
      // 等待页面完全加载
      await new Promise(resolve => {
        hiddenWindow.webContents.once('did-finish-load', resolve);
        // 备用超时
        setTimeout(resolve, 3000);
      });

      // 等待渲染完成
      await new Promise(resolve => setTimeout(resolve, 1000));

      // 截图
      const image = await hiddenWindow.webContents.capturePage();
      
      // 转换为指定格式
      if (format === 'png') {
        return image.toPNG();
      } else {
        return image.toJPEG(quality);
      }
    } finally {
      hiddenWindow.destroy();
    }
  }

  /**
   * 将 HTML 内容转换为 PDF
   */
  static async htmlToPdf(htmlContent: string): Promise<Buffer> {
    // 创建一个隐藏的 BrowserWindow
    const hiddenWindow = new BrowserWindow({
      width: 800,
      height: 600,
      show: false,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        webSecurity: false
      }
    });

    try {
      // 创建适合 PDF 的 HTML 页面
      const fullHtml = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <style>
            @page {
              size: A4;
              margin: 2cm;
            }
            body {
              margin: 0;
              padding: 20px;
              background: white;
              font-family: 'Computer Modern', 'Latin Modern Roman', serif;
              font-size: 16px;
              line-height: 1.6;
              color: #000;
            }
            .header {
              text-align: center;
              margin-bottom: 30px;
              border-bottom: 1px solid #ccc;
              padding-bottom: 20px;
            }
            .content {
              text-align: center;
              font-size: 1.5em;
              margin: 40px 0;
            }
            .footer {
              margin-top: 40px;
              padding-top: 20px;
              border-top: 1px solid #ccc;
              font-size: 0.9em;
              color: #666;
              text-align: center;
            }
            /* KaTeX 样式优化 */
            .katex { font-size: inherit !important; }
            .katex-display { margin: 1em 0 !important; }
            
            /* 打印样式 */
            @media print {
              body { -webkit-print-color-adjust: exact; }
            }
          </style>
        </head>
        <body>
          <div class="header">
            <h1>LaTeX Document Export</h1>
            <p>Generated by TexFlow</p>
          </div>
          <div class="content">
            ${htmlContent}
          </div>
          <div class="footer">
            <p>Exported on ${new Date().toLocaleDateString()}</p>
          </div>
        </body>
        </html>
      `;

      // 加载 HTML 内容
      await hiddenWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(fullHtml)}`);
      
      // 等待页面完全加载
      await new Promise(resolve => {
        hiddenWindow.webContents.once('did-finish-load', resolve);
        setTimeout(resolve, 3000);
      });

      // 等待渲染完成
      await new Promise(resolve => setTimeout(resolve, 1500));

      // 生成 PDF
      const pdfBuffer = await hiddenWindow.webContents.printToPDF({
        pageSize: 'A4',
        margins: {
          top: 2,
          bottom: 2,
          left: 2,
          right: 2
        },
        printBackground: true,
        preferCSSPageSize: true
      });

      return pdfBuffer;
    } finally {
      hiddenWindow.destroy();
    }
  }

  /**
   * 优化 SVG 内容
   */
  static optimizeSvg(svgContent: string): string {
    // 确保 SVG 有正确的命名空间和属性
    if (!svgContent.includes('xmlns')) {
      svgContent = svgContent.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    
    // 添加默认尺寸（如果没有）
    if (!svgContent.includes('width=') && !svgContent.includes('viewBox=')) {
      svgContent = svgContent.replace('<svg', '<svg width="800" height="600"');
    }

    return svgContent;
  }

  /**
   * 检测内容类型并进行适当的转换
   */
  static async convertContent(
    content: string,
    fromFormat: 'html' | 'svg',
    toFormat: 'png' | 'jpg' | 'pdf' | 'svg',
    options: any = {}
  ): Promise<Buffer | string> {
    switch (toFormat) {
      case 'png':
      case 'jpg':
        if (fromFormat === 'html') {
          return await this.htmlToImage(content, toFormat, options);
        } else if (fromFormat === 'svg') {
          // 将 SVG 包装在 HTML 中然后转换
          const htmlContent = `
            <div style="display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">
              ${content}
            </div>
          `;
          return await this.htmlToImage(htmlContent, toFormat, options);
        }
        break;

      case 'pdf':
        if (fromFormat === 'html') {
          return await this.htmlToPdf(content);
        } else if (fromFormat === 'svg') {
          const htmlContent = `
            <div style="display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">
              ${content}
            </div>
          `;
          return await this.htmlToPdf(htmlContent);
        }
        break;

      case 'svg':
        if (fromFormat === 'svg') {
          return this.optimizeSvg(content);
        }
        break;
    }

    throw new Error(`Unsupported conversion: ${fromFormat} to ${toFormat}`);
  }
}
